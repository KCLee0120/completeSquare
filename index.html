<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>魔鬼的計謀：時間拍賣 (Devil's Plan)</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Firebase SDKs (v11.0.2) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-analytics.js";
        import { getDatabase, ref, set, onValue, update, remove, onDisconnect, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-database.js";

        // ==========================================
        // 1. Firebase 設定
        // ==========================================
        const firebaseConfig = {
            apiKey: "AIzaSyC0an_GTA57k9A-QxT-nym024jeAnmma8g",
            authDomain: "timergame-38c86.firebaseapp.com",
            databaseURL: "https://timergame-38c86-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "timergame-38c86",
            storageBucket: "timergame-38c86.firebasestorage.app",
            messagingSenderId: "846034385504",
            appId: "1:846034385504:web:1ca920b5de036c265a2105",
            measurementId: "G-5KKFRQ67DN"
        };

        // 初始化 Firebase
        let app, db, analytics;
        try {
            app = initializeApp(firebaseConfig);
            analytics = getAnalytics(app);
            db = getDatabase(app);
            console.log("Firebase 連線成功");
        } catch (e) {
            console.error("Firebase 初始化失敗", e);
            alert("Firebase 連線失敗");
        }

        // ==========================================
        // 2. 全域變數與狀態
        // ==========================================
        let myId = localStorage.getItem('dp_player_id') || 'player_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('dp_player_id', myId);
        
        let myName = "";
        let currentLocalBid = 0.0;
        let bidInterval = null;
        let isHost = false; 
        
        // 新增：儲存最新的遊戲狀態，供 GameLoop 使用
        let currentGameState = null;
        
        const TOTAL_ROUNDS = 19;
        const INITIAL_TIME = 600.0;
        
        const screens = {
            get login() { return document.getElementById('screen-login'); },
            get lobby() { return document.getElementById('screen-lobby'); },
            get game() { return document.getElementById('screen-game'); },
            get result() { return document.getElementById('screen-result'); }
        };

        // ==========================================
        // 3. 遊戲邏輯
        // ==========================================

        window.joinGame = () => {
            const nameInput = document.getElementById('nickname').value.trim();
            if (!nameInput) return alert("請輸入暱稱");
            
            myName = nameInput;
            
            const playerRef = ref(db, `players/${myId}`);
            set(playerRef, {
                id: myId,
                nickname: myName,
                isReady: false,
                remainingTime: INITIAL_TIME,
                currentBid: 0,
                isHolding: false,
                hasLockedBid: false, 
                joinedAt: serverTimestamp()
            });

            onDisconnect(playerRef).remove();

            screens.login.classList.add('hidden');
            screens.lobby.classList.remove('hidden');
        };

        const handleLeaveGame = () => {
            if (!db) return;

            if (confirm("確定要離開房間嗎？")) {
                const playerRef = ref(db, `players/${myId}`);
                remove(playerRef).then(() => {
                    screens.lobby.classList.add('hidden');
                    screens.login.classList.remove('hidden');
                    
                    isHost = false;
                    document.getElementById('host-indicator').classList.add('hidden');
                    
                    updateReadyButton(false);
                }).catch((error) => {
                    console.error("離開失敗:", error);
                    alert("離開失敗");
                });
            }
        };

        const handleHostStartGame = () => {
            if (!isHost) return;
            // 觸發倒數
            update(ref(db, 'gameState'), { 
                phase: 'LOBBY_COUNTDOWN',
                startTime: Date.now()
            });
        };

        const bindEvents = () => {
            const leaveBtn = document.getElementById('btn-leave');
            if (leaveBtn) {
                leaveBtn.addEventListener('click', handleLeaveGame);
            }
            const hostStartBtn = document.getElementById('btn-host-start');
            if (hostStartBtn) {
                hostStartBtn.addEventListener('click', handleHostStartGame);
            }
        };
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', bindEvents);
        } else {
            bindEvents();
        }

        window.toggleReady = () => {
            const playerRef = ref(db, `players/${myId}/isReady`);
            onValue(playerRef, (snap) => {
                const currentStatus = snap.val();
                update(ref(db, `players/${myId}`), { isReady: !currentStatus });
            }, { onlyOnce: true });
        };

        function updateReadyButton(isReady) {
            const btn = document.getElementById('btn-ready');
            if (!btn) return;

            if (isReady) {
                btn.innerText = "取消準備 (CANCEL)";
                btn.className = "w-full bg-zinc-900 border border-red-600 text-red-500 py-4 rounded font-bold tracking-widest uppercase hover:bg-red-900/20 transition-all";
            } else {
                btn.innerText = "I AM READY";
                btn.className = "w-full bg-zinc-800 border border-green-600 text-green-500 py-4 rounded font-bold tracking-widest uppercase hover:bg-green-900/20 transition-all";
            }
            btn.classList.remove('opacity-50');
            btn.disabled = false;
        }

        // ==========================================
        // 4. Firebase 監聽與 GameLoop
        // ==========================================

        if(db) {
            const gameStateRef = ref(db, 'gameState');
            const playersRef = ref(db, 'players');

            onValue(playersRef, (snapshot) => {
                const players = snapshot.val() || {};
                const playerList = Object.values(players).sort((a,b) => a.joinedAt - b.joinedAt);
                
                if (playerList.length > 0 && playerList[0].id === myId) {
                    isHost = true;
                    const hostInd = document.getElementById('host-indicator');
                    if (hostInd) hostInd.classList.remove('hidden');
                }

                const me = playerList.find(p => p.id === myId);
                if (me) {
                    updateReadyButton(me.isReady);
                }

                renderLobbyList(playerList);
                updateHostStartButton(playerList);
                checkLobbyAbort(playerList);
                checkRoundLogic(playerList); 
                renderScoreboard(playerList);
            });

            onValue(gameStateRef, (snapshot) => {
                const state = snapshot.val();
                if (!state) {
                    if (isHost) {
                        set(gameStateRef, {
                            phase: 'LOBBY',
                            round: 1,
                            roundStartTime: 0
                        });
                    }
                    return;
                }
                
                // 更新全域狀態
                currentGameState = state;
                
                handleStateChange(state);
            });
        }
        
        // 新增：Game Loop (每 100ms 執行一次)
        // 負責倒數計時與時間觸發的狀態切換
        setInterval(() => {
            if (!currentGameState) return;
            const now = Date.now();
            const state = currentGameState;

            // 1. 大廳倒數
            if (state.phase === 'LOBBY_COUNTDOWN') {
                const count = 3 - Math.floor((now - state.startTime) / 1000);
                const el = document.getElementById('lobby-status');
                if (el) el.innerText = `遊戲即將開始... ${Math.max(0, count)}`;
                
                // Host 負責切換狀態
                if (isHost && count < 0) {
                    update(ref(db, 'gameState'), { phase: 'ROUND_PREP', round: 1 });
                    resetPlayersForRound();
                }
            } 
            
            // 2. 回合緩衝倒數 (5秒)
            else if (state.phase === 'ROUND_COUNTDOWN') {
                const count = 5 - Math.floor((now - state.startTime) / 1000);
                const el = document.getElementById('game-status-text');
                if (el) el.innerText = `準備倒數 (鬆手 = 放棄本局)\n${Math.max(0, count)}`;
                
                // Host 負責切換狀態
                if (isHost && count < 0) {
                    update(ref(db, 'gameState'), { phase: 'BIDDING', biddingStartTime: now });
                }
            }

            // 3. 回合結果展示倒數 (5秒)
            else if (state.phase === 'ROUND_RESULT') {
                const count = 5 - Math.floor((now - state.startTime) / 1000);
                const el = document.querySelector('#screen-result p');
                if (el) el.innerText = `NEXT ROUND STARTING IN ${Math.max(0, count)}...`;
                
                // Host 負責切換狀態
                if (isHost && count < 0) {
                     if (state.round >= TOTAL_ROUNDS) {
                        update(ref(db, 'gameState'), { phase: 'GAME_OVER' });
                    } else {
                        update(ref(db, 'gameState'), { phase: 'ROUND_PREP', round: state.round + 1 });
                        resetPlayersForRound();
                    }
                }
            }
        }, 100);

        function handleStateChange(state) {
            if (!state || !state.phase) return;

            // 畫面切換邏輯
            if (state.phase === 'LOBBY' || state.phase === 'LOBBY_COUNTDOWN') {
                showScreen('lobby');
                if (state.phase === 'LOBBY') {
                    document.getElementById('lobby-status').innerText = "WAITING FOR PLAYERS...";
                }
            } else if (state.phase === 'GAME_OVER') {
                showScreen('result');
                document.getElementById('round-winner-text').innerHTML = "遊戲結束<br>Game Over";
            } else {
                showScreen('game');
            }
            
            if (state.phase === 'ROUND_RESULT') {
                showScreen('result');
            }

            const roundDisplay = document.getElementById('round-display');
            if (roundDisplay) roundDisplay.innerText = `Round ${state.round || 1} / ${TOTAL_ROUNDS}`;

            const statusText = document.getElementById('game-status-text');
            const mainBtn = document.getElementById('main-btn');

            // 這裡只處理靜態文字與按鈕樣式，動態倒數交給 setInterval
            switch (state.phase) {
                case 'ROUND_PREP':
                    statusText.innerText = "全員按住按鈕以開始\nHold Button to Start";
                    statusText.className = "text-xl text-yellow-500 font-bold animate-pulse whitespace-pre-line";
                    mainBtn.classList.remove('bg-red-600', 'bg-gray-600');
                    mainBtn.classList.add('bg-blue-600');
                    mainBtn.innerText = "按住準備 (HOLD)";
                    document.getElementById('bid-timer').innerText = "00.0";
                    break;

                case 'ROUND_COUNTDOWN':
                    // 初始文字，之後會被 Loop 覆蓋
                    statusText.className = "text-2xl text-red-500 font-bold whitespace-pre-line";
                    mainBtn.classList.remove('bg-blue-600');
                    mainBtn.classList.add('bg-red-600');
                    mainBtn.innerText = "保持按住...";
                    break;

                case 'BIDDING':
                    statusText.innerText = "競價中！鬆手出價";
                    statusText.className = "text-xl text-green-400 font-bold animate-pulse";
                    mainBtn.innerText = "放手出價 (RELEASE)";
                    break;
            }
        }

        // ==========================================
        // 5. 按鈕互動邏輯
        // ==========================================
        const mainBtn = document.getElementById('main-btn');

        const startHold = (e) => {
            e.preventDefault(); 
            if (!currentGameState) return;
            const state = currentGameState;
            
            if (state.phase === 'ROUND_PREP') {
                update(ref(db, `players/${myId}`), { isHolding: true });
            }
        };

        const endHold = (e) => {
            e.preventDefault();
            if (!currentGameState) return;
            const state = currentGameState;
            
            if (state.phase === 'ROUND_PREP') {
                update(ref(db, `players/${myId}`), { isHolding: false });
            }
            else if (state.phase === 'ROUND_COUNTDOWN') {
                update(ref(db, `players/${myId}`), { 
                    isHolding: false,
                    hasLockedBid: true,
                    currentBid: 0 
                });
                stopLocalTimer();
            }
            else if (state.phase === 'BIDDING') {
                const finalBid = parseFloat(document.getElementById('bid-timer').innerText);
                onValue(ref(db, `players/${myId}`), (pSnap) => {
                    const pData = pSnap.val();
                    if (!pData || pData.hasLockedBid) return;

                    let validBid = finalBid;
                    let newRemaining = pData.remainingTime - finalBid;

                    if (newRemaining < 0) {
                        validBid = pData.remainingTime;
                        newRemaining = 0;
                    }

                    update(ref(db, `players/${myId}`), { 
                        isHolding: false,
                        hasLockedBid: true,
                        currentBid: validBid,
                        remainingTime: newRemaining
                    });
                    stopLocalTimer();
                }, { onlyOnce: true });
            }
        };

        if (mainBtn) {
            mainBtn.addEventListener('mousedown', startHold);
            mainBtn.addEventListener('touchstart', startHold);
            mainBtn.addEventListener('mouseup', endHold);
            mainBtn.addEventListener('touchend', endHold);
            mainBtn.addEventListener('mouseleave', endHold);
        }

        function startLocalTimer(startTime) {
            if (bidInterval) clearInterval(bidInterval);
            const timerEl = document.getElementById('bid-timer');
            
            bidInterval = setInterval(() => {
                const now = Date.now();
                const delta = (now - startTime) / 1000;
                currentLocalBid = delta.toFixed(1);
                if (timerEl) timerEl.innerText = currentLocalBid;
            }, 50);
        }

        function stopLocalTimer() {
            if (bidInterval) clearInterval(bidInterval);
            bidInterval = null;
        }

        if (db) {
            onValue(ref(db, 'gameState'), (snap) => {
                const state = snap.val();
                if (state && state.phase === 'BIDDING') {
                    onValue(ref(db, `players/${myId}/isHolding`), (pSnap) => {
                        if (pSnap && pSnap.val() === true) {
                            startLocalTimer(state.biddingStartTime);
                        }
                    }, { onlyOnce: true });
                }
            });
        }

        // ==========================================
        // 6. Host 邏輯
        // ==========================================
        
        function updateHostStartButton(playerList) {
            const btn = document.getElementById('btn-host-start');
            if (!btn) return;

            if (isHost) {
                btn.classList.remove('hidden');
                
                const allReady = playerList.length >= 2 && playerList.every(p => p.isReady);
                
                if (allReady) {
                    btn.disabled = false;
                    btn.classList.remove('opacity-50', 'cursor-not-allowed');
                    btn.innerText = "START GAME";
                } else {
                    btn.disabled = true;
                    btn.classList.add('opacity-50', 'cursor-not-allowed');
                    const readyCount = playerList.filter(p=>p.isReady).length;
                    btn.innerText = `WAITING FOR ALL READY (${readyCount}/${playerList.length})`;
                }
            } else {
                btn.classList.add('hidden');
            }
        }

        function checkLobbyAbort(playerList) {
            if (!isHost) return;
            const allReady = playerList.length >= 2 && playerList.every(p => p.isReady);
            
            if (currentGameState && currentGameState.phase === 'LOBBY_COUNTDOWN' && !allReady) {
                update(ref(db, 'gameState'), { phase: 'LOBBY' });
            }
        }

        function checkRoundLogic(playerList) {
            if (!isHost) return;
            // 使用 currentGameState 避免依賴 onValue 快照
            if (!currentGameState) return;
            const state = currentGameState;
            
            if (state.phase === 'ROUND_PREP') {
                const activePlayers = playerList.filter(p => p.remainingTime > 0);
                const allHolding = activePlayers.length > 0 && activePlayers.every(p => p.isHolding);
                if (allHolding) {
                    update(ref(db, 'gameState'), { 
                        phase: 'ROUND_COUNTDOWN',
                        startTime: Date.now()
                    });
                }
            }
            
            if (state.phase === 'BIDDING') {
                 const activePlayers = playerList.filter(p => p.remainingTime > 0);
                 const allFinished = activePlayers.every(p => p.hasLockedBid);
                 if (allFinished) {
                     determineWinner(activePlayers);
                 }
            }
        }

        function determineWinner(players) {
            const sorted = players.sort((a,b) => b.currentBid - a.currentBid);
            let winnerId = null;
            let maxBid = -1;
            
            if (sorted.length > 0) {
                if (sorted.length === 1 || sorted[0].currentBid > sorted[1].currentBid) {
                    if (sorted[0].currentBid > 0) {
                        winnerId = sorted[0].id;
                        maxBid = sorted[0].currentBid;
                    }
                }
            }
            
            update(ref(db, 'gameState'), { 
                phase: 'ROUND_RESULT',
                startTime: Date.now(),
                lastWinnerId: winnerId,
                lastWinnerBid: maxBid
            });
            
            if (winnerId) {
                const winner = players.find(p => p.id === winnerId);
                const currentScore = winner.score || 0;
                update(ref(db, `players/${winnerId}`), { score: currentScore + 1 });
            }
        }

        function resetPlayersForRound() {
            onValue(ref(db, 'players'), (snap) => {
                const updates = {};
                snap.forEach(child => {
                    updates[`${child.key}/isHolding`] = false;
                    updates[`${child.key}/hasLockedBid`] = false;
                    updates[`${child.key}/currentBid`] = 0;
                });
                update(ref(db, 'players'), updates);
            }, { onlyOnce: true });
        }

        // ==========================================
        // 7. 渲染 UI
        // ==========================================
        
        function showScreen(screenName) {
            const login = document.getElementById('screen-login');
            const lobby = document.getElementById('screen-lobby');
            const game = document.getElementById('screen-game');
            const result = document.getElementById('screen-result');
            
            if(login) login.classList.add('hidden');
            if(lobby) lobby.classList.add('hidden');
            if(game) game.classList.add('hidden');
            if(result) result.classList.add('hidden');
            
            const target = document.getElementById('screen-' + screenName);
            if(target) target.classList.remove('hidden');
        }

        function renderLobbyList(list) {
            const container = document.getElementById('lobby-player-list');
            if (!container) return;
            container.innerHTML = list.map(p => `
                <div class="flex justify-between items-center p-3 bg-gray-800 rounded border ${p.isReady ? 'border-green-500' : 'border-gray-600'}">
                    <span class="text-white font-mono">${p.nickname}</span>
                    <span class="text-xs ${p.isReady ? 'text-green-400' : 'text-gray-400'}">${p.isReady ? 'READY' : 'WAITING'}</span>
                </div>
            `).join('');
        }
        
        function renderScoreboard(list) {
            const container = document.getElementById('ingame-scoreboard');
            if (container) {
                container.innerHTML = list.map(p => `
                    <div class="flex justify-between text-xs mb-1 ${p.id === myId ? 'text-yellow-400 font-bold' : 'text-gray-400'}">
                        <span>${p.nickname}</span>
                        <span>Tokens: ${p.score || 0}</span>
                    </div>
                `).join('');
            }

            const resultContainer = document.getElementById('result-list');
            if (currentGameState && (currentGameState.phase === 'ROUND_RESULT' || currentGameState.phase === 'GAME_OVER') && resultContainer) {
                 const winnerId = currentGameState.lastWinnerId;
                 const winnerBid = currentGameState.lastWinnerBid;
                 const sortedByScore = [...list].sort((a, b) => (b.score || 0) - (a.score || 0));

                 const winnerText = document.getElementById('round-winner-text');
                 if (winnerText) {
                     if (winnerId) {
                         const winner = list.find(p => p.id === winnerId);
                         winnerText.innerHTML = 
                             `<span class="text-yellow-400 text-3xl">${winner ? winner.nickname : 'Unknown'}</span><br>Wins with ${winnerBid}s`;
                     } else {
                         winnerText.innerHTML = 
                             `<span class="text-gray-400">No Winner<br><span class="text-sm">(Tie or 0 bid)</span></span>`;
                     }
                 }
                 
                 resultContainer.innerHTML = sortedByScore.map((p, index) => `
                    <div class="flex justify-between items-center bg-black/30 p-2 rounded">
                        <div class="flex items-center gap-2">
                            <span class="text-gray-500 font-mono w-4">${index + 1}</span>
                            <span class="${p.id === myId ? 'text-yellow-400' : 'text-white'}">${p.nickname}</span>
                        </div>
                        <span class="font-mono text-yellow-600">${p.score || 0} pts</span>
                    </div>
                 `).join('');
            }
        }

    </script>
    <style>
        .no-select {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        .animate-fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
</head>
<body class="bg-[#111] text-gray-100 h-screen w-screen overflow-hidden font-sans no-select" oncontextmenu="return false;">

    <!-- Login -->
    <div id="screen-login" class="flex flex-col items-center justify-center h-full p-6">
        <h1 class="text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-red-500 to-yellow-500 mb-8 tracking-tighter">TIME AUCTION</h1>
        <div class="w-full max-w-sm bg-zinc-900 p-6 rounded-xl border border-zinc-800 shadow-2xl">
            <label class="block text-gray-400 text-sm mb-2">ENTER NICKNAME</label>
            <input type="text" id="nickname" class="w-full bg-black text-white p-4 rounded border border-gray-700 focus:border-red-500 outline-none text-center text-xl mb-6" placeholder="PLAYER 1">
            <button onclick="joinGame()" class="w-full bg-gradient-to-r from-red-700 to-red-900 text-white py-4 rounded font-bold tracking-widest hover:brightness-110 active:scale-95 transition-all">ENTER DEATH MATCH</button>
        </div>
        <p class="text-gray-600 text-xs mt-8">DEVIL'S PLAN SEASON 2 FAN MADE</p>
    </div>

    <!-- Lobby -->
    <div id="screen-lobby" class="hidden flex flex-col h-full p-6">
        <div class="flex justify-between items-center mb-6">
            <button id="btn-leave" class="text-xs text-red-500 border border-red-900 px-3 py-1 rounded hover:bg-red-900/30 transition-colors">
                LEAVE
            </button>
            <h2 class="text-xl font-bold text-gray-300">LOBBY</h2>
            <span id="host-indicator" class="hidden text-xs bg-yellow-900 text-yellow-200 px-2 py-1 rounded">YOU ARE HOST</span>
        </div>
        
        <div id="lobby-status" class="text-center text-yellow-500 text-lg mb-4 font-mono h-8">WAITING FOR PLAYERS...</div>
        
        <div id="lobby-player-list" class="flex-1 space-y-2 overflow-y-auto mb-6">
            <!-- List -->
        </div>

        <!-- HOST START BUTTON (新增) -->
        <button id="btn-host-start" class="hidden w-full mb-4 bg-yellow-600 border border-yellow-400 text-white py-4 rounded font-bold tracking-widest uppercase hover:bg-yellow-700 transition-all shadow-lg shadow-yellow-900/50">
            START GAME
        </button>

        <button id="btn-ready" onclick="toggleReady()" class="w-full bg-zinc-800 border border-green-600 text-green-500 py-4 rounded font-bold tracking-widest uppercase hover:bg-green-900/20 transition-all">
            I AM READY
        </button>
    </div>

    <!-- Game -->
    <div id="screen-game" class="hidden flex flex-col h-full relative">
        <div class="bg-zinc-900 p-4 border-b border-zinc-800 flex justify-between items-center z-10">
            <span id="round-display" class="font-mono text-xl text-gray-300">ROUND 1 / 19</span>
            <span class="text-xs text-gray-500">HIDDEN TIMER</span>
        </div>

        <div class="flex-1 flex flex-col items-center justify-center p-4 relative">
            <div id="game-status-text" class="text-center mb-8 whitespace-pre-line leading-relaxed">
                WAITING FOR SIGNAL...
            </div>
            <div id="bid-timer" class="text-7xl font-mono font-bold text-white tracking-tighter drop-shadow-[0_0_10px_rgba(255,255,255,0.5)]">
                00.0
            </div>
            <p class="text-gray-500 text-xs mt-2 font-mono">SECONDS STAKED</p>
        </div>

        <div class="h-1/2 w-full p-6 pb-10 flex flex-col">
            <button id="main-btn" class="flex-1 w-full bg-gray-600 rounded-2xl shadow-[0_0_30px_rgba(0,0,0,0.5)] border-4 border-white/10 text-2xl font-bold tracking-widest transition-all active:scale-[0.98] active:brightness-110 flex items-center justify-center text-white select-none touch-manipulation">
                WAIT
            </button>
            <div id="ingame-scoreboard" class="mt-4 h-24 overflow-y-auto bg-black/50 p-2 rounded text-xs border border-white/5">
                <!-- Score -->
            </div>
        </div>
    </div>

    <!-- Result -->
    <div id="screen-result" class="hidden absolute inset-0 bg-black/90 z-50 flex flex-col items-center justify-center p-6 animate-fade-in">
        <h2 class="text-gray-400 tracking-[0.5em] text-sm mb-6">ROUND RESULT</h2>
        <div class="w-64 h-64 rounded-full border-4 border-yellow-500 flex items-center justify-center bg-yellow-900/20 mb-8 shadow-[0_0_50px_rgba(234,179,8,0.3)]">
            <div id="round-winner-text" class="text-center font-bold">
            </div>
        </div>
        <div class="w-full max-w-md bg-zinc-900 p-4 rounded border border-zinc-700">
            <h3 class="text-xs text-gray-500 mb-2 uppercase">Current Standings</h3>
            <div id="result-list" class="space-y-2">
            </div>
        </div>
        <p class="text-white/30 text-xs mt-8 animate-pulse">NEXT ROUND STARTING SOON...</p>
    </div>

</body>
</html>
