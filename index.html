<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>魔鬼的計謀：時間拍賣 (Devil's Plan)</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Firebase SDKs (v11.0.2) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-analytics.js";
        import { getDatabase, ref, set, onValue, update, remove, onDisconnect, serverTimestamp, get } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-database.js";

        // ==========================================
        // 1. Firebase 設定
        // ==========================================
        const firebaseConfig = {
            apiKey: "AIzaSyC0an_GTA57k9A-QxT-nym024jeAnmma8g",
            authDomain: "timergame-38c86.firebaseapp.com",
            databaseURL: "https://timergame-38c86-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "timergame-38c86",
            storageBucket: "timergame-38c86.firebasestorage.app",
            messagingSenderId: "846034385504",
            appId: "1:846034385504:web:1ca920b5de036c265a2105",
            measurementId: "G-5KKFRQ67DN"
        };

        let app, db, analytics;
        try {
            app = initializeApp(firebaseConfig);
            analytics = getAnalytics(app);
            db = getDatabase(app);
            console.log("Firebase 連線成功");
        } catch (e) {
            console.error("Firebase 初始化失敗", e);
            alert("Firebase 連線失敗");
        }

        // ==========================================
        // 2. 時間同步校準
        // ==========================================
        let serverTimeOffset = 0;
        const getServerTime = () => {
            return Date.now() + serverTimeOffset;
        };

        if (db) {
            const offsetRef = ref(db, ".info/serverTimeOffset");
            onValue(offsetRef, (snap) => {
                serverTimeOffset = snap.val();
            });
        }

        // ==========================================
        // 3. 全域變數與狀態
        // ==========================================
        let myId = localStorage.getItem('dp_player_id') || 'player_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('dp_player_id', myId);
        
        let myName = "";
        let bidInterval = null;
        let isHost = false; 
        let currentGameState = null;
        let localBiddingStartTime = 0; 
        let cachedPlayerList = []; 
        let myRemainingTimeCache = 0; // 緩存我的剩餘時間，用於自動鬆手檢查
        
        let GAME_CONFIG = {
            totalRounds: 19,
            initialTimeMinutes: 10
        };
        
        const ROUND_LINGER_TIME = 3; 
        const RESULT_SHOW_TIME = 5;  
        const TOTAL_RESULT_PHASE_TIME = ROUND_LINGER_TIME + RESULT_SHOW_TIME;
        
        const screens = {
            get login() { return document.getElementById('screen-login'); },
            get lobby() { return document.getElementById('screen-lobby'); },
            get game() { return document.getElementById('screen-game'); },
            get result() { return document.getElementById('screen-result'); },
            get aborted() { return document.getElementById('screen-aborted'); }
        };

        // ==========================================
        // 4. 遊戲邏輯
        // ==========================================

        window.joinGame = () => {
            const nameInput = document.getElementById('nickname').value.trim();
            if (!nameInput) return alert("請輸入暱稱");
            
            myName = nameInput;
            
            const playerRef = ref(db, `players/${myId}`);
            set(playerRef, {
                id: myId,
                nickname: myName,
                isReady: false,
                remainingTime: GAME_CONFIG.initialTimeMinutes * 60, 
                score: 0,
                currentBid: 0,
                isHolding: false,
                hasLockedBid: false, 
                bidHistory: {}, 
                joinedAt: serverTimestamp()
            });

            onDisconnect(playerRef).remove();

            screens.login.classList.add('hidden');
            screens.lobby.classList.remove('hidden');
        };

        const handleLeaveGame = () => {
            if (!db) return;
            if (confirm("確定要離開房間嗎？")) {
                const playerRef = ref(db, `players/${myId}`);
                remove(playerRef).then(() => {
                    screens.lobby.classList.add('hidden');
                    screens.login.classList.remove('hidden');
                    isHost = false;
                    document.getElementById('host-indicator').classList.add('hidden');
                    updateReadyButton(false);
                }).catch((error) => {
                    console.error("離開失敗:", error);
                    alert("離開失敗");
                });
            }
        };

        window.updateGameConfig = (type, value) => {
            if (!isHost) return;
            const updates = {};
            if (type === 'time') {
                updates['gameState/config/initialTimeMinutes'] = parseInt(value);
            } else if (type === 'rounds') {
                updates['gameState/config/totalRounds'] = parseInt(value);
            }
            update(ref(db), updates);
        };

        const handleHostStartGame = async () => {
            if (!isHost) return;
            
            const configSnap = await get(ref(db, 'gameState/config'));
            const config = configSnap.val() || GAME_CONFIG;
            const startSeconds = config.initialTimeMinutes * 60;

            const updates = {};
            const activePlayerIds = cachedPlayerList.map(p => p.id);
            updates['gameState/activePlayers'] = activePlayerIds;

            cachedPlayerList.forEach(p => {
                updates[`players/${p.id}/remainingTime`] = startSeconds;
                updates[`players/${p.id}/score`] = 0;
                updates[`players/${p.id}/currentBid`] = 0;
                updates[`players/${p.id}/isHolding`] = false;
                updates[`players/${p.id}/hasLockedBid`] = false;
                updates[`players/${p.id}/bidHistory`] = null; 
            });
            
            updates['gameState/phase'] = 'LOBBY_COUNTDOWN';
            updates['gameState/startTime'] = serverTimestamp();
            updates['gameState/round'] = 1;

            await update(ref(db), updates);
        };

        const handleHostResetGame = async () => {
            if (!isHost) return;
            if (!confirm("確定要重置遊戲並回到大廳嗎？")) return;

            const configSnap = await get(ref(db, 'gameState/config'));
            const config = configSnap.val() || GAME_CONFIG;
            const startSeconds = config.initialTimeMinutes * 60;

            const updates = {};
            
            cachedPlayerList.forEach(p => {
                updates[`players/${p.id}/remainingTime`] = startSeconds;
                updates[`players/${p.id}/score`] = 0;
                updates[`players/${p.id}/currentBid`] = 0;
                updates[`players/${p.id}/isHolding`] = false;
                updates[`players/${p.id}/hasLockedBid`] = false;
                updates[`players/${p.id}/bidHistory`] = null; 
                updates[`players/${p.id}/isReady`] = false; 
            });

            updates['gameState/phase'] = 'LOBBY';
            updates['gameState/round'] = 1;
            updates['gameState/lastWinnerId'] = null;
            updates['gameState/lastWinnerBid'] = null;
            updates['gameState/activePlayers'] = null; 

            await update(ref(db), updates);
        };

        const abortGame = async (missingPlayerIds) => {
            if (!isHost) return;
            
            const updates = {};
            const currentRound = currentGameState.round;

            updates['gameState/phase'] = 'GAME_ABORTED';
            updates['gameState/abortTime'] = serverTimestamp();
            
            cachedPlayerList.forEach(p => {
                updates[`players/${p.id}/bidHistory/${currentRound}`] = null;
                updates[`players/${p.id}/currentBid`] = 0;
                updates[`players/${p.id}/isHolding`] = false;
                updates[`players/${p.id}/hasLockedBid`] = false;
            });

            await update(ref(db), updates);

            setTimeout(() => {
                if (currentGameState && currentGameState.phase === 'GAME_ABORTED') {
                    handleHostResetGame();
                }
            }, 3000);
        };

        const bindEvents = () => {
            const leaveBtn = document.getElementById('btn-leave');
            if (leaveBtn) leaveBtn.addEventListener('click', handleLeaveGame);
            
            const hostStartBtn = document.getElementById('btn-host-start');
            if (hostStartBtn) hostStartBtn.addEventListener('click', handleHostStartGame);
            
            const hostResetBtn = document.getElementById('btn-host-reset');
            if (hostResetBtn) hostResetBtn.addEventListener('click', handleHostResetGame);
        };
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', bindEvents);
        } else {
            bindEvents();
        }

        window.toggleReady = () => {
            const playerRef = ref(db, `players/${myId}/isReady`);
            onValue(playerRef, (snap) => {
                const currentStatus = snap.val();
                update(ref(db, `players/${myId}`), { isReady: !currentStatus });
            }, { onlyOnce: true });
        };

        function updateReadyButton(isReady) {
            const btn = document.getElementById('btn-ready');
            if (!btn) return;
            if (isReady) {
                btn.innerText = "取消準備 (CANCEL)";
                btn.className = "w-full bg-zinc-900 border border-red-600 text-red-500 py-4 rounded font-bold tracking-widest uppercase hover:bg-red-900/20 transition-all";
            } else {
                btn.innerText = "I AM READY";
                btn.className = "w-full bg-zinc-800 border border-green-600 text-green-500 py-4 rounded font-bold tracking-widest uppercase hover:bg-green-900/20 transition-all";
            }
            btn.classList.remove('opacity-50');
            btn.disabled = false;
        }

        // ==========================================
        // 5. Firebase 監聽 & 連線檢測
        // ==========================================

        if(db) {
            const gameStateRef = ref(db, 'gameState');
            const playersRef = ref(db, 'players');

            onValue(playersRef, (snapshot) => {
                const players = snapshot.val() || {};
                
                const playerList = Object.values(players).sort((a,b) => {
                    const tA = (typeof a.joinedAt === 'number') ? a.joinedAt : Number.MAX_SAFE_INTEGER;
                    const tB = (typeof b.joinedAt === 'number') ? b.joinedAt : Number.MAX_SAFE_INTEGER;
                    return tA - tB;
                });
                
                cachedPlayerList = playerList;

                if (playerList.length > 0 && playerList[0].id === myId) {
                    isHost = true;
                    document.getElementById('host-indicator').classList.remove('hidden');
                    enableConfigInputs(true);
                } else {
                    isHost = false;
                    document.getElementById('host-indicator').classList.add('hidden');
                    enableConfigInputs(false);
                }

                const me = playerList.find(p => p.id === myId);
                if (me) {
                    updateReadyButton(me.isReady);
                    myRemainingTimeCache = me.remainingTime || 0; // 更新剩餘時間緩存
                }

                renderLobbyList(playerList);
                updateHostStartButton(playerList);
                checkLobbyAbort(playerList);
                checkActivePlayersConnection(playerList); 
                checkRoundLogic(playerList); 
                renderScoreboard(playerList);
            });

            onValue(gameStateRef, (snapshot) => {
                const state = snapshot.val();
                if (!state) {
                    if (isHost) {
                        set(gameStateRef, {
                            phase: 'LOBBY',
                            round: 1,
                            config: {
                                totalRounds: 19,
                                initialTimeMinutes: 10
                            }
                        });
                    }
                    return;
                }
                
                currentGameState = state;
                
                if (state.config) {
                    GAME_CONFIG = state.config;
                    updateConfigUI(state.config);
                }

                handleStateChange(state);
                renderScoreboard(cachedPlayerList);
            });
        }
        
        function enableConfigInputs(enabled) {
            document.getElementById('conf-time').disabled = !enabled;
            document.getElementById('conf-rounds').disabled = !enabled;
            const inputs = document.querySelectorAll('.conf-input');
            inputs.forEach(el => {
                if(enabled) {
                    el.classList.remove('opacity-50', 'cursor-not-allowed');
                } else {
                    el.classList.add('opacity-50', 'cursor-not-allowed');
                }
            });
        }

        function updateConfigUI(config) {
            const timeInput = document.getElementById('conf-time');
            const roundInput = document.getElementById('conf-rounds');
            if (document.activeElement !== timeInput) timeInput.value = config.initialTimeMinutes;
            if (document.activeElement !== roundInput) roundInput.value = config.totalRounds;
        }

        function checkActivePlayersConnection(currentPlayers) {
            if (!isHost || !currentGameState) return;
            
            const phase = currentGameState.phase;
            const isGameRunning = phase === 'ROUND_PREP' || phase === 'ROUND_COUNTDOWN' || phase === 'BIDDING' || phase === 'ROUND_RESULT';
            
            if (isGameRunning && currentGameState.activePlayers) {
                const activeIds = currentGameState.activePlayers; 
                const currentIds = currentPlayers.map(p => p.id);
                const missingIds = activeIds.filter(id => !currentIds.includes(id));
                
                if (missingIds.length > 0) {
                    abortGame(missingIds);
                }
            }
        }

        // ==========================================
        // 6. Game Loop (核心計時與強制結束)
        // ==========================================
        setInterval(() => {
            try {
                if (!currentGameState || !currentGameState.phase) return;
                
                const now = getServerTime();
                const state = currentGameState;
                const startTime = state.startTime || state.biddingStartTime || now;

                if (state.phase === 'LOBBY_COUNTDOWN') {
                    const elapsed = (now - startTime) / 1000;
                    const count = 3 - elapsed;
                    const el = document.getElementById('lobby-status');
                    if (el) el.innerText = `遊戲即將開始... ${Math.max(0, Math.ceil(count))}`;
                    
                    if (isHost && count <= 0) {
                        update(ref(db, 'gameState'), { phase: 'ROUND_PREP', round: 1 });
                        resetPlayersForRound();
                    }
                } 
                else if (state.phase === 'ROUND_COUNTDOWN') {
                    const elapsed = (now - startTime) / 1000;
                    const count = 5 - elapsed;
                    const el = document.getElementById('game-status-text');
                    if (el) el.innerText = `準備倒數 (鬆手 = 放棄本局)\n${Math.max(0, Math.ceil(count))}`;
                    
                    if (isHost && count <= 0) {
                        update(ref(db, 'gameState'), { phase: 'BIDDING', biddingStartTime: getServerTime() });
                    }
                }
                else if (state.phase === 'ROUND_RESULT') {
                    const elapsed = (now - startTime) / 1000;
                    const totalRemaining = TOTAL_RESULT_PHASE_TIME - elapsed;
                    
                    const el = document.getElementById('result-timer-text');
                    if (el) el.innerText = `NEXT ROUND IN ${Math.max(0, Math.ceil(totalRemaining))}...`;
                    
                    if (isHost && totalRemaining <= 0) {
                         if (state.round >= GAME_CONFIG.totalRounds) {
                            update(ref(db, 'gameState'), { phase: 'GAME_OVER' });
                        } else {
                            update(ref(db, 'gameState'), { phase: 'ROUND_PREP', round: state.round + 1 });
                            resetPlayersForRound();
                        }
                    }
                }
                // 自動鬆手檢測 (Auto-Release Check)
                else if (state.phase === 'BIDDING') {
                    // 如果我正在按住，且時間已用盡
                    // 這裡的 bidInterval 負責更新 UI，這裡負責邏輯檢測
                    if (localBiddingStartTime > 0) {
                        const delta = (now - localBiddingStartTime) / 1000;
                        const myPlayer = cachedPlayerList.find(p => p.id === myId);
                        
                        // 確保我們拿到的是最新的 myRemainingTimeCache (從 onValue 更新)
                        // 如果時間到了，且我還沒鎖定
                        if (myPlayer && !myPlayer.hasLockedBid && delta >= myRemainingTimeCache) {
                            console.log("Time up! Auto releasing...");
                            endHold(new Event('mouseup')); // 強制觸發鬆手
                        }
                    }
                }
            } catch (err) {
                console.error("Game loop error:", err);
            }
        }, 100);

        function handleStateChange(state) {
            if (!state || !state.phase) return;

            const login = document.getElementById('screen-login');
            const lobby = document.getElementById('screen-lobby');
            const game = document.getElementById('screen-game');
            const result = document.getElementById('screen-result');
            const aborted = document.getElementById('screen-aborted');
            
            const hideAll = () => {
                if(login) login.classList.add('hidden');
                if(lobby) lobby.classList.add('hidden');
                if(game) game.classList.add('hidden');
                if(result) result.classList.add('hidden');
                if(aborted) aborted.classList.add('hidden');
            };

            if (state.phase === 'LOBBY' || state.phase === 'LOBBY_COUNTDOWN') {
                hideAll();
                if(lobby) lobby.classList.remove('hidden');
                if (state.phase === 'LOBBY') {
                    const el = document.getElementById('lobby-status');
                    if(el) el.innerText = "WAITING FOR PLAYERS...";
                }
            } else if (state.phase === 'GAME_OVER') {
                hideAll();
                if(result) result.classList.remove('hidden');
                document.getElementById('round-winner-text').innerHTML = "遊戲結束<br>Game Over";
                const timerEl = document.getElementById('result-timer-text');
                if(timerEl) timerEl.classList.add('hidden');
                
                const resetBtn = document.getElementById('btn-host-reset');
                if (isHost) {
                    resetBtn.classList.remove('hidden');
                } else {
                    resetBtn.classList.add('hidden');
                }
                
                renderScoreboard(cachedPlayerList);

            } else if (state.phase === 'GAME_ABORTED') {
                hideAll();
                if(aborted) aborted.classList.remove('hidden');

            } else if (state.phase === 'ROUND_RESULT') {
                document.getElementById('btn-host-reset').classList.add('hidden');
                stopLocalTimer();
                if (localBiddingStartTime > 0) {
                    const finalTime = (state.startTime - localBiddingStartTime) / 1000;
                    document.getElementById('bid-timer').innerText = Math.max(0, finalTime).toFixed(1);
                }

                hideAll();
                if(game) game.classList.remove('hidden'); 
                
                setTimeout(() => {
                    if (currentGameState && currentGameState.phase === 'ROUND_RESULT') {
                        hideAll();
                        if(result) result.classList.remove('hidden');
                        const timerEl = document.getElementById('result-timer-text');
                        if(timerEl) timerEl.classList.remove('hidden');
                    }
                }, ROUND_LINGER_TIME * 1000);

            } else {
                hideAll();
                if(game) game.classList.remove('hidden');
                document.getElementById('btn-host-reset').classList.add('hidden');
            }

            const roundDisplay = document.getElementById('round-display');
            if (roundDisplay) roundDisplay.innerText = `Round ${state.round || 1} / ${GAME_CONFIG.totalRounds}`;

            const statusText = document.getElementById('game-status-text');
            const mainBtn = document.getElementById('main-btn');

            switch (state.phase) {
                case 'ROUND_PREP':
                    statusText.innerText = "全員按住按鈕以開始\nHold Button to Start";
                    statusText.className = "text-xl text-yellow-500 font-bold animate-pulse whitespace-pre-line";
                    mainBtn.classList.remove('bg-red-600', 'bg-gray-600');
                    mainBtn.classList.add('bg-blue-600');
                    mainBtn.innerText = "按住準備 (HOLD)";
                    document.getElementById('bid-timer').innerText = "00.0";
                    break;

                case 'ROUND_COUNTDOWN':
                    statusText.className = "text-2xl text-red-500 font-bold whitespace-pre-line";
                    mainBtn.classList.remove('bg-blue-600');
                    mainBtn.classList.add('bg-red-600');
                    mainBtn.innerText = "保持按住...";
                    break;

                case 'BIDDING':
                    statusText.innerText = "競價中！鬆手出價";
                    statusText.className = "text-xl text-green-400 font-bold animate-pulse";
                    mainBtn.innerText = "放手出價 (RELEASE)";
                    if (state.biddingStartTime) {
                        localBiddingStartTime = state.biddingStartTime;
                        startLocalTimer(state.biddingStartTime);
                    }
                    break;
            }
        }

        // ==========================================
        // 7. 按鈕互動 & 計時器
        // ==========================================
        const mainBtn = document.getElementById('main-btn');

        const startHold = (e) => {
            if (e.cancelable) e.preventDefault();
            if (!currentGameState) return;
            const state = currentGameState;
            if (state.phase === 'ROUND_PREP') {
                update(ref(db, `players/${myId}`), { isHolding: true });
            }
        };

        const endHold = (e) => {
            if (e && e.cancelable) e.preventDefault();
            if (!currentGameState) return;
            const state = currentGameState;
            
            if (state.phase === 'ROUND_PREP') {
                update(ref(db, `players/${myId}`), { isHolding: false });
            }
            else if (state.phase === 'ROUND_COUNTDOWN') {
                update(ref(db, `players/${myId}`), { 
                    isHolding: false,
                    hasLockedBid: true,
                    currentBid: 0 
                });
                stopLocalTimer();
            }
            else if (state.phase === 'BIDDING') {
                const bidStart = state.biddingStartTime || localBiddingStartTime;
                const now = getServerTime(); 
                let finalBid = (now - bidStart) / 1000;
                finalBid = Math.max(0, finalBid); 
                
                // 檢查是否超過剩餘時間，超過則強制為剩餘時間
                if (finalBid > myRemainingTimeCache) {
                    finalBid = myRemainingTimeCache;
                }
                
                onValue(ref(db, `players/${myId}`), (pSnap) => {
                    const pData = pSnap.val();
                    if (!pData || pData.hasLockedBid) return;

                    let validBid = finalBid;
                    let newRemaining = pData.remainingTime - finalBid;

                    if (newRemaining < 0) {
                        validBid = pData.remainingTime;
                        newRemaining = 0;
                    }

                    update(ref(db, `players/${myId}`), { 
                        isHolding: false,
                        hasLockedBid: true,
                        currentBid: validBid,
                        remainingTime: newRemaining
                    });
                }, { onlyOnce: true });
            }
        };

        if (mainBtn) {
            mainBtn.addEventListener('mousedown', startHold);
            mainBtn.addEventListener('touchstart', startHold);
            mainBtn.addEventListener('mouseup', endHold);
            mainBtn.addEventListener('touchend', endHold);
            mainBtn.addEventListener('mouseleave', endHold);
        }

        function startLocalTimer(startTime) {
            if (bidInterval) clearInterval(bidInterval);
            const timerEl = document.getElementById('bid-timer');
            bidInterval = setInterval(() => {
                const now = getServerTime(); 
                const delta = (now - startTime) / 1000;
                // 更新 UI，但不要超過我的剩餘時間
                let displayTime = Math.max(0, delta);
                if (displayTime > myRemainingTimeCache) {
                    displayTime = myRemainingTimeCache;
                }
                if (timerEl) timerEl.innerText = displayTime.toFixed(1);
            }, 50);
        }

        function stopLocalTimer() {
            if (bidInterval) clearInterval(bidInterval);
            bidInterval = null;
        }

        if (db) {
            onValue(ref(db, 'gameState'), (snap) => {
                const state = snap.val();
                if (state && state.phase === 'BIDDING') {
                    localBiddingStartTime = state.biddingStartTime;
                    startLocalTimer(state.biddingStartTime);
                }
            });
        }

        // ==========================================
        // 8. Host 輔助邏輯
        // ==========================================
        
        function updateHostStartButton(playerList) {
            const btn = document.getElementById('btn-host-start');
            if (!btn) return;

            if (isHost) {
                btn.classList.remove('hidden');
                const allReady = playerList.length >= 2 && playerList.every(p => p.isReady);
                if (allReady) {
                    btn.disabled = false;
                    btn.classList.remove('opacity-50', 'cursor-not-allowed');
                    btn.innerText = "START GAME";
                } else {
                    btn.disabled = true;
                    btn.classList.add('opacity-50', 'cursor-not-allowed');
                    const readyCount = playerList.filter(p=>p.isReady).length;
                    btn.innerText = `WAITING FOR ALL READY (${readyCount}/${playerList.length})`;
                }
            } else {
                btn.classList.add('hidden');
            }
        }

        function checkLobbyAbort(playerList) {
            if (!isHost) return;
            const allReady = playerList.length >= 2 && playerList.every(p => p.isReady);
            if (currentGameState && currentGameState.phase === 'LOBBY_COUNTDOWN' && !allReady) {
                update(ref(db, 'gameState'), { phase: 'LOBBY' });
            }
        }

        function checkRoundLogic(playerList) {
            if (!isHost) return;
            if (!currentGameState) return;
            const state = currentGameState;
            
            // 準備階段：全員按住 (不管時間剩多少) -> 倒數
            if (state.phase === 'ROUND_PREP') {
                // 修正：包含所有玩家，不論時間
                const activePlayers = playerList; 
                const allHolding = activePlayers.length > 0 && activePlayers.every(p => p.isHolding);
                if (allHolding) {
                    update(ref(db, 'gameState'), { 
                        phase: 'ROUND_COUNTDOWN',
                        startTime: getServerTime() 
                    });
                }
            }
            
            if (state.phase === 'BIDDING') {
                 // 篩選出有剩餘時間的玩家
                 const activePlayers = playerList.filter(p => p.remainingTime > 0);
                 
                 // 判定條件 1: 所有"有時間"的玩家都已鎖定出價
                 const allFinished = activePlayers.every(p => p.hasLockedBid);
                 
                 // 判定條件 2: 所有"有時間"的玩家都已鬆手 (全員放棄)
                 // 這能解決「雖然沒鎖定 (hasLockedBid=false)，但沒人按住」的僵局
                 const nobodyIsHolding = activePlayers.every(p => !p.isHolding);

                 // 如果全員完成 OR (全員鬆手 AND 遊戲已進行了一點時間)
                 // 加一點延遲判定 (e.g. 500ms) 防止剛開始的一瞬間誤判
                 const timeSinceStart = Date.now() - (state.biddingStartTime || 0);

                 if (allFinished || (nobodyIsHolding && timeSinceStart > 1000)) {
                     determineWinner(playerList); // 傳入所有玩家進行結算
                 }
            }
        }

        async function determineWinner(players) {
            const sorted = players.sort((a,b) => b.currentBid - a.currentBid);
            let winnerId = null;
            let maxBid = -1;
            
            if (sorted.length > 0) {
                if (sorted.length === 1 || sorted[0].currentBid > sorted[1].currentBid) {
                    if (sorted[0].currentBid > 0) {
                        winnerId = sorted[0].id;
                        maxBid = sorted[0].currentBid;
                    }
                }
            }
            
            const updates = {};
            const round = currentGameState.round;
            const startTime = getServerTime(); 

            players.forEach(p => {
                updates[`players/${p.id}/bidHistory/${round}`] = p.currentBid || 0;
            });

            if (winnerId) {
                const winner = players.find(p => p.id === winnerId);
                const currentScore = winner.score || 0;
                updates[`players/${winnerId}/score`] = currentScore + 1;
            }

            updates['gameState/phase'] = 'ROUND_RESULT';
            updates['gameState/startTime'] = startTime;
            updates['gameState/lastWinnerId'] = winnerId;
            updates['gameState/lastWinnerBid'] = maxBid;

            await update(ref(db), updates);
        }

        function resetPlayersForRound() {
            onValue(ref(db, 'players'), (snap) => {
                const updates = {};
                snap.forEach(child => {
                    updates[`${child.key}/isHolding`] = false;
                    updates[`${child.key}/hasLockedBid`] = false;
                    updates[`${child.key}/currentBid`] = 0;
                });
                update(ref(db, 'players'), updates);
            }, { onlyOnce: true });
        }

        // ==========================================
        // 9. 渲染 UI
        // ==========================================
        
        function renderLobbyList(list) {
            const container = document.getElementById('lobby-player-list');
            if (!container) return;
            container.innerHTML = list.map(p => `
                <div class="flex justify-between items-center p-3 bg-gray-800 rounded border ${p.isReady ? 'border-green-500' : 'border-gray-600'}">
                    <span class="text-white font-mono">${p.nickname}</span>
                    <span class="text-xs ${p.isReady ? 'text-green-400' : 'text-gray-400'}">${p.isReady ? 'READY' : 'WAITING'}</span>
                </div>
            `).join('');
        }
        
        function renderScoreboard(list) {
            const container = document.getElementById('ingame-scoreboard');
            if (container) {
                container.innerHTML = list.map(p => `
                    <div class="flex justify-between text-xs mb-1 ${p.id === myId ? 'text-yellow-400 font-bold' : 'text-gray-400'}">
                        <span>${p.nickname}</span>
                        <span>Tokens: ${p.score || 0}</span>
                    </div>
                `).join('');
            }

            const resultContainer = document.getElementById('result-list');
            if (currentGameState && (currentGameState.phase === 'ROUND_RESULT' || currentGameState.phase === 'GAME_OVER') && resultContainer) {
                 const winnerId = currentGameState.lastWinnerId;
                 const winnerBid = currentGameState.lastWinnerBid;
                 const sortedByScore = [...list].sort((a, b) => (b.score || 0) - (a.score || 0));

                 const winnerText = document.getElementById('round-winner-text');
                 if (winnerText && currentGameState.phase === 'ROUND_RESULT') {
                     if (winnerId) {
                         const winner = list.find(p => p.id === winnerId);
                         winnerText.innerHTML = 
                             `<span class="text-yellow-400 text-3xl">${winner ? winner.nickname : 'Unknown'}</span><br>Wins with ${winnerBid}s`;
                     } else {
                         winnerText.innerHTML = 
                             `<span class="text-gray-400">No Winner<br><span class="text-sm">(Tie or 0 bid)</span></span>`;
                     }
                 }
                 
                 resultContainer.innerHTML = sortedByScore.map((p, index) => `
                    <div class="flex justify-between items-center bg-black/30 p-2 rounded">
                        <div class="flex items-center gap-2">
                            <span class="text-gray-500 font-mono w-4">${index + 1}</span>
                            <span class="${p.id === myId ? 'text-yellow-400' : 'text-white'}">${p.nickname}</span>
                        </div>
                        <span class="font-mono text-yellow-600">${p.score || 0} pts</span>
                    </div>
                 `).join('');

                 const loserContainer = document.getElementById('loser-container');
                 const historyContainer = document.getElementById('history-container');
                 
                 if (currentGameState.phase === 'GAME_OVER') {
                     if (loserContainer) {
                         loserContainer.classList.remove('hidden');
                         const minScore = sortedByScore[sortedByScore.length - 1].score || 0;
                         const losers = sortedByScore.filter(p => (p.score || 0) === minScore);
                         const loserNames = losers.map(p => p.nickname).join(', ');
                         document.getElementById('loser-text').innerText = loserNames;
                     }
                     if (historyContainer) {
                         historyContainer.classList.remove('hidden');
                         renderHistoryTable(list, GAME_CONFIG.totalRounds);
                     }
                 } else {
                     if (loserContainer) loserContainer.classList.add('hidden');
                     if (historyContainer) historyContainer.classList.add('hidden');
                 }
            }
        }

        function renderHistoryTable(players, totalRounds) {
             const tableBody = document.getElementById('history-table-body');
             const tableHead = document.getElementById('history-table-head');
             if (!tableBody || !tableHead) return;

             let headHtml = `<th class="px-2 py-1 sticky left-0 bg-gray-700 z-10 text-yellow-500">Player</th>`;
             headHtml += `<th class="px-2 py-1 bg-gray-700 min-w-[80px]">Rem. Time</th>`;
             for(let i=1; i<=totalRounds; i++) {
                 headHtml += `<th class="px-2 py-1 bg-gray-700 min-w-[50px]">R${i}</th>`;
             }
             tableHead.innerHTML = `<tr>${headHtml}</tr>`;

             tableBody.innerHTML = players.map(p => {
                 let rowHtml = `<td class="px-2 py-1 sticky left-0 bg-gray-800 font-bold text-white border-r border-gray-600">${p.nickname}</td>`;
                 rowHtml += `<td class="px-2 py-1 text-green-400 font-mono">${(p.remainingTime || 0).toFixed(1)}</td>`;
                 for(let i=1; i<=totalRounds; i++) {
                     const bid = p.bidHistory && p.bidHistory[i] ? p.bidHistory[i] : 0;
                     const displayBid = bid > 0 ? bid.toFixed(1) : '<span class="text-gray-600">-</span>';
                     rowHtml += `<td class="px-2 py-1 border-l border-gray-700 font-mono text-gray-300 text-center">${displayBid}</td>`;
                 }
                 return `<tr class="border-b border-gray-700 hover:bg-white/5">${rowHtml}</tr>`;
             }).join('');
        }

    </script>
    <style>
        .no-select {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        .animate-fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        input[type=number]::-webkit-inner-spin-button {
            opacity: 1;
        }
    </style>
</head>
<body class="bg-[#111] text-gray-100 h-[100dvh] w-screen overflow-hidden font-sans no-select" oncontextmenu="return false;">

    <!-- Login -->
    <div id="screen-login" class="flex flex-col items-center justify-center h-full p-6 overflow-y-auto">
        <h1 class="text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-red-500 to-yellow-500 mb-8 tracking-tighter">TIME AUCTION</h1>
        <div class="w-full max-w-sm bg-zinc-900 p-6 rounded-xl border border-zinc-800 shadow-2xl">
            <label class="block text-gray-400 text-sm mb-2">ENTER NICKNAME</label>
            <input type="text" id="nickname" class="w-full bg-black text-white p-4 rounded border border-gray-700 focus:border-red-500 outline-none text-center text-xl mb-6" placeholder="PLAYER 1">
            <button onclick="joinGame()" class="w-full bg-gradient-to-r from-red-700 to-red-900 text-white py-4 rounded font-bold tracking-widest hover:brightness-110 active:scale-95 transition-all">ENTER DEATH MATCH</button>
        </div>
        <p class="text-gray-600 text-xs mt-8">DEVIL'S PLAN SEASON 2 FAN MADE</p>
    </div>

    <!-- Lobby -->
    <div id="screen-lobby" class="hidden flex flex-col h-full p-6 overflow-y-auto">
        <div class="flex justify-between items-center mb-6 shrink-0">
            <button id="btn-leave" class="text-xs text-red-500 border border-red-900 px-3 py-1 rounded hover:bg-red-900/30 transition-colors">
                LEAVE
            </button>
            <h2 class="text-xl font-bold text-gray-300">LOBBY</h2>
            <span id="host-indicator" class="hidden text-xs bg-yellow-900 text-yellow-200 px-2 py-1 rounded">YOU ARE HOST</span>
        </div>
        
        <!-- Game Settings -->
        <div class="bg-zinc-900 p-4 rounded-lg border border-zinc-800 mb-4 shrink-0">
            <h3 class="text-xs text-gray-500 mb-3 uppercase tracking-wider">Game Settings</h3>
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-gray-400 text-xs mb-1">TIME (MINS)</label>
                    <input type="number" id="conf-time" min="5" max="10" value="10" 
                           onchange="updateGameConfig('time', this.value)"
                           class="conf-input w-full bg-black text-white p-2 rounded border border-gray-700 text-center font-mono focus:border-yellow-500 outline-none">
                </div>
                <div>
                    <label class="block text-gray-400 text-xs mb-1">ROUNDS</label>
                    <input type="number" id="conf-rounds" min="9" max="19" value="19"
                           onchange="updateGameConfig('rounds', this.value)" 
                           class="conf-input w-full bg-black text-white p-2 rounded border border-gray-700 text-center font-mono focus:border-yellow-500 outline-none">
                </div>
            </div>
        </div>
        
        <div id="lobby-status" class="text-center text-yellow-500 text-lg mb-4 font-mono h-8 shrink-0">WAITING FOR PLAYERS...</div>
        
        <div id="lobby-player-list" class="space-y-2 mb-6 w-full">
            <!-- List -->
        </div>

        <div class="mt-auto w-full space-y-4 shrink-0 pb-6">
            <button id="btn-host-start" class="hidden w-full bg-yellow-600 border border-yellow-400 text-white py-4 rounded font-bold tracking-widest uppercase hover:bg-yellow-700 transition-all shadow-lg shadow-yellow-900/50">
                START GAME
            </button>

            <button id="btn-ready" onclick="toggleReady()" class="w-full bg-zinc-800 border border-green-600 text-green-500 py-4 rounded font-bold tracking-widest uppercase hover:bg-green-900/20 transition-all">
                I AM READY
            </button>
        </div>
    </div>

    <!-- Game -->
    <div id="screen-game" class="hidden flex flex-col h-full relative">
        <div class="bg-zinc-900 p-4 border-b border-zinc-800 flex justify-between items-center z-10 shrink-0">
            <span id="round-display" class="font-mono text-xl text-gray-300">ROUND 1 / 19</span>
            <span class="text-xs text-gray-500">HIDDEN TIMER</span>
        </div>

        <div class="flex-1 flex flex-col items-center justify-center p-4 relative">
            <div id="game-status-text" class="text-center mb-8 whitespace-pre-line leading-relaxed">
                WAITING FOR SIGNAL...
            </div>
            <div id="bid-timer" class="text-7xl font-mono font-bold text-white tracking-tighter drop-shadow-[0_0_10px_rgba(255,255,255,0.5)]">
                00.0
            </div>
            <p class="text-gray-500 text-xs mt-2 font-mono">SECONDS STAKED</p>
        </div>

        <div class="h-1/2 w-full p-6 pb-10 flex flex-col shrink-0">
            <button id="main-btn" class="flex-1 w-full bg-gray-600 rounded-2xl shadow-[0_0_30px_rgba(0,0,0,0.5)] border-4 border-white/10 text-2xl font-bold tracking-widest transition-all active:scale-[0.98] active:brightness-110 flex items-center justify-center text-white select-none touch-manipulation">
                WAIT
            </button>
            <div id="ingame-scoreboard" class="mt-4 h-24 overflow-y-auto bg-black/50 p-2 rounded text-xs border border-white/5">
                <!-- Score -->
            </div>
        </div>
    </div>

    <!-- Result -->
    <div id="screen-result" class="hidden absolute inset-0 bg-black/90 z-50 flex flex-col p-6 animate-fade-in overflow-y-auto">
        
        <div class="w-full max-w-md mx-auto flex flex-col items-center">
            <h2 class="text-gray-400 tracking-[0.5em] text-sm mb-6 mt-10">ROUND RESULT</h2>
            <div class="w-64 h-64 rounded-full border-4 border-yellow-500 flex items-center justify-center bg-yellow-900/20 mb-8 shadow-[0_0_50px_rgba(234,179,8,0.3)] shrink-0">
                <div id="round-winner-text" class="text-center font-bold">
                </div>
            </div>
            
            <p id="result-timer-text" class="text-white/50 text-xs mb-4 animate-pulse">NEXT ROUND IN 5...</p>

            <div class="w-full bg-zinc-900 p-4 rounded border border-zinc-700 mb-6">
                <h3 class="text-xs text-gray-500 mb-2 uppercase">Current Standings</h3>
                <div id="result-list" class="space-y-2 mb-4">
                    <!-- Standings -->
                </div>

                <div id="loser-container" class="hidden mt-4 pt-4 border-t border-zinc-700 text-center">
                    <h3 class="text-xs text-red-500 mb-1 uppercase tracking-widest">ELIMINATED</h3>
                    <div id="loser-text" class="text-xl font-bold text-red-600">
                    </div>
                </div>
            </div>

            <!-- RESET BUTTON (HOST ONLY) -->
            <button id="btn-host-reset" class="hidden w-full mb-8 bg-red-800 border border-red-600 text-white py-4 rounded font-bold tracking-widest uppercase hover:bg-red-900 transition-all shadow-lg">
                PLAY AGAIN / RESET LOBBY
            </button>
        </div>

        <div id="history-container" class="hidden w-full max-w-4xl mx-auto mt-6 mb-10">
            <h3 class="text-xs text-gray-500 mb-2 uppercase tracking-widest text-center">Match History</h3>
            <div class="overflow-x-auto bg-zinc-900 rounded border border-zinc-800 shadow-xl">
                <table class="w-full text-xs text-left whitespace-nowrap">
                    <thead id="history-table-head" class="text-gray-400 bg-zinc-800 uppercase">
                    </thead>
                    <tbody id="history-table-body" class="text-gray-300">
                    </tbody>
                </table>
            </div>
        </div>

    </div>

    <!-- ABORTED Screen -->
    <div id="screen-aborted" class="hidden absolute inset-0 bg-red-900/90 z-50 flex flex-col items-center justify-center p-6 animate-fade-in text-center">
        <h1 class="text-4xl font-bold text-white mb-4">GAME ABORTED</h1>
        <p class="text-xl text-red-200">A player has disconnected.</p>
        <p class="text-sm text-red-300 mt-2">Returning to Lobby...</p>
    </div>

</body>
</html>
